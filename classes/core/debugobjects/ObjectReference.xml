<class name="ObjectReference" HierImageField="Image" fauthor="$Author: $" fdate="$Date: $" frevision="$Revision: $">
<members>
<Integer name="DebugID" />
<Integer name="Address" />
<String name="ClassName" />
<Integer name="ChildAddress" />
<List name="Children" cls="classes::core::debugobjects::ObjectReference" />
<Integer name="ChildDebugID" />
<Integer name="hasCircularReference" />
<String name="image" />
<method name="SetChildrenFromFile">
<param name="fileName" type="string" />
<![CDATA[//@cmember SetChildrenFromFile
//@param string | fileName |
//@version Jonathan.Muir | 22-03-13 14:13 |
//@i Set up the hierarchy from the result of a sys::WriteObjectReferencesToFile

classes::core::debugobjects::ObjectReference list[];

file f;
if(!f.open(fileName))
{
    return "Error opening file: "+sys::GetLastHERROR();
}
else
{
    string header = f.ReadLine();
    while(!f.IsEOF())
    {
        string line = f.ReadLine();
        classes::core::debugobjects::objectReference ref = &list.createRowBin(line.gettoken(2).val());
        ref.ClassName = line.gettoken(0);
        ref.Address = line.gettoken(1).val();
        ref.DebugID = line.gettoken(2).val();
        ref.ChildAddress = line.gettoken(4).val();
        ref.childdebugid = line.gettoken(5).val();
    }
}

//root.Children.reset();

classes::cpickn accountedfor[];

for(int i=0;i<list.count();i++)
{
    AddNode(accountedfor,list[i].debugID,list[i].Address,Children,list,null);
}

return "";]]>
</method>
<method name="setHasCircularReference">
<param name="b" type="int" />
<![CDATA[//@cmember setHasCircularReference
//@param int | b |
//@version Jonathan.Muir | 22-03-13 13:06 |
//@i

image = b?"classes::resource::standard::hsubjectnew.bmp":"";]]>
</method>
<method name="getHasCircularReference" return="int">
<![CDATA[//@cmember getHasCircularReference
//@return int |
//@version Jonathan.Muir | 22-03-13 13:09 |
//@i

return (image=="classes::resource::standard::hsubjectnew.bmp");]]>
</method>
</members>
<static>
<method name="AddNode">
<param name="accountedFor" type="list" />
<param name="nodeDebugID" type="int" />
<param name="nodeaddress" type="int" />
<param name="hier" type="list" />
<param name="fulllist" type="list" />
<param name="pbranchroot" type="classes::core::unittests::objectreference" />
<![CDATA[//@cmember AddNode
//@param list | accountedFor |
//@param int | nodeDebugID |
//@param int | nodeaddress |
//@param list | hier |
//@param list | fulllist |
//@param classes::core::debugobjects::objectreference | pbranchroot |
//@version Jonathan.Muir | 22-03-13 14:13 |
//@i

// Check that we don't already have this address accounted for

// Find all the items for this address

object branchroot = pbranchroot;


// Have we seen this node before

if(accountedfor.FindRowBin(nodeaddress)==null)
{
    classes::core::debugobjects::ObjectReference hiernode = &hier.CreateRow();
    hiernode.Address = nodeaddress;

    object forclassname = fulllist.FindRowBin(nodeDebugID);
    if(forclassname==NULL) hiernode.ClassName = "Not in list";
    else hiernode.ClassName = forclassname.ClassName;

    if(branchroot==null) branchroot = hiernode;

    classes::cpickn thisAddress = &accountedfor.CreateRowBin(nodeaddress);
    thisAddress.code = nodeaddress;

    for(int i=0;i<fulllist.count();i++)
    {
        if(fulllist[i].ChildAddress&&fulllist[i].address==nodeaddress)
        {
            AddNode(accountedFor,fulllist[i].childdebugid,fulllist[i].ChildAddress,hiernode.Children,fulllist,branchroot);
        }
    }
}
else
{
    // This node is already accounted for - chech to see if we have a circular reference

    // loop through this branch

    if(branchroot!=null)
    {
        classes::core::debugobjects::ObjectReference hiernode = &hier.CreateRow();
        hiernode.Address = nodeaddress;

        object forclassname = fulllist.FindRowBin(nodeDebugID);
        if(forclassname==NULL) hiernode.ClassName = "Not in list";
        else hiernode.ClassName = forclassname.ClassName;
        hierNode.ClassName+=", Seen before";


        if(CheckForNode(branchroot,nodeAddress))
        {
            // Mark all parents
            MarkCircularReferences(hierNode);

        }
    }

}]]>
</method>
<method name="CheckForNode">
<param name="node" type="classes::core::unittests::objectreference" />
<param name="address" type="int" />
<![CDATA[//@cmember CheckForNode
//@param classes::core::debugobjects::objectreference | node |
//@param int | address |
//@version Jonathan.Muir | 22-03-13 14:13 |
//@i

if(node.Address == address)
{
    return 1;
}

for(int i=0;i<node.Children.Count();i++)
{
    if(CheckForNode(node.Children[i],address)==1)
    {
        return 1;
    }
}

return 0;]]>
</method>
<method name="MarkCircularReferences">
<param name="node" type="classes::core::unittests::objectreference" />
<![CDATA[//@cmember MarkCircularReferences
//@param classes::core::debugobjects::objectreference | node |
//@version Jonathan.Muir | 22-03-13 14:13 |
//@i

node.setHasCircularReference(1);
MList list = &node.OwnerList();
if(list!=null)
{
    object row = list.OwnerRow();
    if(row!=null)
    {
        MarkCircularReferences(row);
    }
}]]>
</method>
</static>
<disp>
<e f="ClassName" sfx=", " />
<e f="Address" />
</disp>
<return>
<rmeth name="getHasCircularReference" cls="int" />
</return>
</class>
